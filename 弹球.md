![Alt text](../../E:/pheny-blog/img/11.png)
![Alt text](../../E:/pheny-blog/img/12.png)
### 12-18
#### 思考
###### 怎么完成一个弹球项目？
A给画板,计数器分配变量
B在画板中,画很多个大小一样,颜色不太一样的小球
C让小球在屏幕里跑步

###### 弹球数怎么写呢？
###### 弹球和恶魔圈怎么写呢？
#### 归纳
##### javascript 
###### -面向对象oo 属性方法集成体,意思就是要手把手教电脑干活
###### 






##### web-api接口
###### -canvas画板 这个在html中选择器是`<canvas></canvas>` 
##### javascript 
###### -回调函数 适合在另一个函数中调用
###### -HTMLCanvasElement.getContext() 这是画布对象创建画物方法 ,例:`const ctx = canvas.getContext('2d'); //ctx为二维物体` 在画布中，括号里要画物为二维图形
##### -CanvasRenderingContext2D.
###### -beginPath()这是创建边
###### -closePath()这是闭合边
###### -moveTo() -lineTo()这是边坐标
###### -stroke()这是勾边
###### -fill()这是填充
###### strokeRect()这是画矩形   
###### -fillRect()画有内容的矩形，括号里是坐标     ###### -fillStyle 这个图形的颜色
###### -strokeStyle 创建边后换画物轮廓颜色    
###### -lineWidth 换轮廓尺码 -save()     
###### -clearRect()清除，括号里是清除范围 
###### -arc()画圆，括号里是坐标    
###### -rotate(angle)旋转，括号里是旋转的角度    ###### -translat(x,y)平移,括号里是平移距离 
###### -setTranform()图形变形 括号里是变换坐标 transform()同  
######  -beginPath()创建不同路径


##### -window.
###### -requestAnimationFrame(callback)绘制方法 括号里的绘制函数通过浏览器刷新时间绘制图形坐标,刷多少次绘制多少次，直到坐标是我们想要的为止，如果卡顿，就延长间隔时间

##### -performance.now()这个方法出时间戳 -DOMHighResTimeStamp时间戳 这里演示的是动画变化方法里的回调函数接收到的时间戳

##### css 
###### -transform 例子：transform: translateX(2em);//这里做了一个平移动作
###### -top距离顶部属性 -right距离右边属性 -absolute在整个body大盒子里的位置 -margin距离边框属性 
```
p {
  position: absolute;
  margin: 0;
  top: 35px;
  right: 5px;
  color: #aaa;
} 
```
![Alt text](../../E:/pheny-blog/img/14.png)
###### 这里Top,right是正数 ，代表这行字都在里面
![Alt text](../../E:/pheny-blog/img/15.png)
###### 这里演示的p盒子 在html盒子的body盒子中
###### -毫秒 微观时间,1秒类比一米,等于1000毫秒 
###### reflow重排,在浏览器中,优化重排就是把修改操作记录下来,重排就是重新计算渲染树
###### -刷新率 就是每几毫秒画面就变化的意思 小于10毫秒就变化的画面就很流畅
```
let start, previousTimeStamp; 
let done = false;   
function step(timestamp) {
  if (start === undefined) {
    start = timestamp;  
  }
  const elapsed = timestamp - start; 
  console.log(previousTimeStamp)  //undefined  19.9 36.6 53.2... 1003.2 1019.8 上一次绘制时间
  console.log(timestamp)   // 19.9 36.6 53.2 69.9...1019.8 1036.6 绘制时间
  if (previousTimeStamp !== timestamp){ 
    // 这里使用 Math.min() 确保元素在恰好位于 100px 时停止运动
    const count = Math.min(0.1 * elapsed, 100); 
    element.style.transform = `translateX(${count}px)`;
    if (count === 100) done = true;
  }

  if (elapsed < 1000) {
    // 1 秒之后停止动画
    previousTimeStamp = timestamp;
    if (!done) {
      window.requestAnimationFrame(step);
    }
  }
}

window.requestAnimationFrame(step);
```
<video src="img/16.mp4" width="800px" height="600px" controls="controls"></video>

###### 上图演示 在60个绘制板中的绘制时间、上一次的绘制时间、第一个绘制板中的绘制时间、和第一个绘制板间隔绘制时间 
#### 总结 
###### 了解Web API 接口参考 -canvas 
###### 学会html -p css -top
###### 了解使用canvas  -CanvasRenderingContext2D. 在画板中，二维图形对象的方法
###### 了解window.requestAnimationFrame()
###### 了解DOMHighResTimeStamp 
###### 了解毫秒
###### 了解回调函数,了解同步回调和异步回调
###### 了解重排 
###### 了解浏览器刷新率FPS  


### 12-20
#### 归纳
```
ctx.beginPath();
ctx.strokeStyle = "yellow";
ctx.fillStyle = "yellow";
ctx.arc(200, 175, 60, 0, 2 * Math.PI);
ctx.fill();
ctx.stroke();
```
###### 这里我画了一个黄色的圆
```
var ball = {
  x: 200,
  y: 200,
  radius: 25,
  draw: function (color) {
    ctx.beginPath();
    ctx.strokeStyle = "white";
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.fill();
  },
};

ball.draw("pink");
```
###### 这里我通过小球这个对象的画球方法出了一个粉球
```
function runBall() {
  ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ball.draw("pink");
  ball.x += ball.vx;
  ball.y += ball.vy;
   if (ball.y + ball.vy > canvas.height || ball.y + ball.vy < 0) {
    ball.vy = -ball.vy;
  }
  if (ball.x + ball.vx > canvas.width || ball.x + ball.vx < 0) {
    ball.vx = -ball.vx;
  window.requestAnimationFrame(runBall);
}
window.requestAnimationFrame(runBall);
```
###### 这里通过绘制方法出一个跑步的粉球,在绘制函数中，A通过粉球坐标矢量反转，粉球就一直在屏幕里 B通过一个半透明黑矩形，让粉球有长尾效果


#### 总结
###### 学会用canvas画一个圆
###### 理解面向对象，并且制造了一个对象
###### 学会了window.requestAnimationFrame(callback)
###### 了解rgba(0,0,0,0.1)
###### 学会一个跑步的球动画




### 12-21
#### 思考
## 归纳
### javascript
#### 对象
#####  对象原型 
```
const myObject = {
  city: "Madrid",
  greet() {
    console.log(`来自 ${this.city} 的问候`);
  },
};
myObject.greet(); // 来自 Madrid 的问候
```
![Alt text](../../E:/pheny-blog/img/16.png)
###### -这里用myObject做演示,通过控制台,可以看到如_proto_这些..就是代码中看不到的属性
![Alt text](../../E:/pheny-blog/img/17.png)
###### 对象原型和原型链 上图是说明,上面的_proto_在代码中访问如图所示
![Alt text](../../E:/pheny-blog/img/18.png)
![Alt text](../../E:/pheny-blog/img/19.png)
###### 上面的myObject对象的原型为Object.prototype,上图是通过myObject.__proto__演示了该对象

###### -Object.create()和构造函数 
![Alt text](../../E:/pheny-blog/img/20.png)
```
const personPrototype = {
  greet() {
    console.log(`你好，我的名字是 ${this.name}！`);
  },
};

function Person(name) {
  this.name = name;
}

Object.assign(Person.prototype, personPrototype);
// 或
// Person.prototype.greet = personPrototype.greet;
const reuben = new Person("Reuben");
reuben.greet(); 
const irma = new Person("Irma");

console.log(Object.hasOwn(irma, "name")); // true
console.log(Object.hasOwn(irma, "greet")); // false
```
![Alt text](../../E:/pheny-blog/img/21.png)
###### 上面演示将reuben分配为Person对象创建的对象,
###### 自有属性,这里演示imra通过Object.hasOwn()检查属上面Person对象的属性
#### 总结
###### 学习对象原型基本概念
###### 了解面向对象编程基本概念


### 12-22
#### 思考
###### 
#### 归纳
##### 面向对象编程
###### -类 就是把对象归类，方便我们教计算机做事 -实例 就是在分类模板里，通过构造函数完成
#####
#### 总结 
###### 在vscode中，安装markdown edge-tools
###### 了解在面向对象编程中 -类和实例 继承 封装
###### 学会类与实例基本概念，学会构造函数完成实例

### 12-23
#### 思考
A给球归为形状类 B在形状类中，有颜色，半径，坐标，移动距离
###### 
#### 归纳
##### 面向对象编程
###### -类 就是把对象归类，方便我们教计算机做事 -实例 就是在分类模板里，通过构造函数完成 -多态 每个类的方法通过相同函数表现不同效果 -重写(重载) 在多态里的子类们干的事
 ![Alt text](img/01.png)
 ###### 这里演示的是一个类的伪代码
###### -封装 命令计算机做事
###### -在构造函数完成的对象中，另一个对象的方法通过Object.assign()绑定到这个对象的prototype属性上

```
class Shape {
  x;y;vx;vy;

  constructor(x,y,color,vx,vy,radious) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
  }

  introduceSelf() {
    console.log(`Hi! I'm ${this.x}`);
  }
  
}
class Ball extends Shape{
  color;radious;

  constructor(x,y,color,vx,vy,radious) {
    super(x,y,vx,vy);
    this.color = color;
    this.radious = radious;
  }

  introduceSelf() {
    console.log(
      `My name is ${this.x}, and I will be your ${this.color} professor.`,
    );
  }
  grade(paper) {
    const grade = Math.floor(Math.random() * (5 - 1) + 1);
    console.log(grade);
  }
  #somePrivateMethod() {
    console.log("You called me?");
  }
  somePublicMethod() {
    this.#somePrivateMethod();
  }
}

const giles = new Ball ("1","","2");

giles.introduceSelf(); 
giles.grade("paper");
giles.somePublicMethod(); 
```
##### 上面我们把球归为形状，通过球的方法做了一个介绍，一个计算，以及通过球的另一个方法访问球的封装的方法
#####
#### 总结 
###### 在vscode中，安装markdown edge-tools
###### 了解在面向对象编程中 -类和实例 继承 封装
###### 学会类与实例基本概念，学会构造函数完成实例
###### 原型链和继承的区别 -委派 就是计算机出厂自带对象不用教就会做事
###### 学会面向对象编程基本概念
###### 学会使用面向对象编程

### 12-24
#### 思考
###### 怎么给圆形归类？
A给形状类坐标属性 形状对象的构造器  形状位置方法 B儿子球类半径，颜色，画球方法 B通过窗口对象的绘制方法绘制球类动画 
###### 怎么告诉计算机我要画25个大小不等颜色不等的球？
A给球队分配为数组 B在条件循环中，完成球对象 C然后通过球队的方法往球队里添加 
#### 归纳
```
class Shape {
  x;
  y;
  vx;
  vy;
  constructor(x, y,vx,vy) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
  }
  introduceShape() {
    console.log(` this position is: (${this.x}, ${this.y} ),this moveLength is: (${this.vx}, ${this.vy}) `);
  }
}

```
###### 这里是形状类
class Ball extends Shape {
  radious;color;
  constructor(x,y,vx,vy,radious,color){
    super(x,y,vx,vy);
    this.radious = radious;
    this.color =color;
  }
  darw(){
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radious,0,Math.PI*2,);
    ctx.closePath();
    ctx.fillStyle = this.color;
    ctx.fill()
  }
   updated() {
    if(this.x+this.radious>width){
      this.vx = -this.vx;
    }
    if(this.x-this.radious<=0){
      this.vx = -this.vx;
    }
    if(this.y+this.radious>width){
      this.vy = -this.vy;
    }
    if(this.y-this.radious<=0){
      this.vy = -this.vy;
    }
    
  this.x += this.vx;
  this.y += this.vy;
  }
  introduceShape() {
    console.log(` this position is: (${this.x}, ${this.y} ),this moveLength is: (${this.vx}, ${this.vy}) `);
  }

}
###### 这里是继承形状类的球类，在球类中，有画球方法和改变球位置的方法，上面有个矢量反转，让球一直在屏幕里

```
const ballarr = [];
while(ballarr.length<25){
  let size = random(10, 20);
  let ball = new Ball(
    // 为避免绘制错误，球至少离画布边缘球本身一倍宽度的距离
    random(0 + size, width - size),
    random(0 + size, height - size),
    random(-7, 7),
    random(-7, 7),
    size,
    randomColor(),
  );
  ballarr.push(ball);
  console.log(ballarr.push(ball));
}
```
###### 这里用了While条件循环，先捏球，再网球队里添加了25个球
```
// 生成随机数的函数

function random(min, max) {
  const num = Math.floor(Math.random() * (max - min)) + min;
  return num;
}

//生成随机颜色
function randomColor() {
  return (
    "rgb(" +
    random(0, 255) +
    ", " +
    random(0, 255) +
    ", " +
    random(0, 255) +
    ")"
  );
}
```
###### 这里随机坐标，随机半径，随机颜色都是整数，通过Math对象的floor方法取整，在方法中放入区间
```
//绘制球形动画
function loop() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
  ctx.fillRect(0, 0, width, height);
 for(let i=0;i<ballarr.length;i++){
   ballarr[i].darw();
   ballarr[i].updated();
 }
 window.requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);
```
###### 这里是绘制球形动画 绘制函数中，通过for遍历循环球队，绘制每个球
ballarr.forEach(element => {
  element.draw();
  element.updated();
});
###### 上面通过foreach遍历循环球队，绘制每个球
#### 总结
##### 完成弹球的动画
##### 学会while条件循环 for循环 foreach循环

### 12-31
#### 思考
###### 怎么完成恶魔圈呢？
A在恶魔圈子类中，有画恶魔圈方法，有让恶魔圈待屏幕里的方法，有恶魔圈吃小球的方法 B完成恶魔圈类的实例C添加绘制恶魔圈对象动画 
###### 怎么完成计数器呢？
A给计数器分配一个选择器吗
#### 归纳
```
class EvilCircle extends Shape {
  radious=10;color="white";
  constructor(x,y,vx,vy,exists){
    super(x,y,20,20,exists);
  }
  draw() {
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.arc(this.x, this.y, this.radious, 0, Math.PI * 2);
    ctx.closePath();
   ctx.stroke();
  }
}
```
###### 这里我用Evilircle类演示，半径颜色分配右边操作数，构造器的参数在上面，画恶魔圈方法这里是画了一个白色边的圆
```
  checkBounds(){
    if (this.x + this.radious > width) {
      this.x -= this.radious;
    }
    if (this.x - this.radious <= 0) {
      this.x += this.radious;
    }
    if (this.y + this.radious > height) {
      this.y -= this.radious;
    }
    if (this.y - this.radious <= 0) {
      this.y += this.radious;
    }
  }
  ```
  ###### 这里方法是让恶魔圈一直在屏幕里
  ```
  setControls(){
    window.onkeydown = (e) => {
      switch (e.key) {
        case "a":
          this.x -= this.vx;
          break;
        case "d":
          this.x += this.vx;
          break;
        case "w":
          this.y -= this.vy;
          break;
        case "s":
          this.y += this.vy;
          break;
      }
    };
  }
  ```
  ###### 这里方法是让键盘控制恶魔圈
  ```
  collisionDetect(ballarr){
    ballarr.forEach((element,index) => {
      if (element.exists) {
        const dx = this.x - element.x;
        const dy = this.y - element.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < this.radious + element.radious) {
         ballarr.splice(index,1)
        }
      }
    });
  }
  ```
  ###### 这里方法是让恶魔圈吃掉小球，这里我放了index,就是在恶魔圈中，让每个还存在的小球都做一次碰撞检测，通过小球数组对象的splice()方法移除该小球
  ```
  //完成恶魔圈类的实例
  const circle = new EvilCircle(200,300,"","",true)
  console.log(circle)
//恶魔圈对象的键盘控制方法
circle.setControls();
```
###### 这里是通过new 恶魔圈实例操控恶魔圈

```
//绘制球形动画
function loop() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
  ctx.fillRect(0, 0, width, height);
  circle.draw();
  circle.checkBounds();
  circle.collisionDetect(ballarr);
  
    ballarr.forEach((element) => {
      if(element.exists){
        element.draw();
        element.updated();
        element.collisionDetect(ballarr);
      }
    });
  
  window.requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);
  ```
###### 这里在绘制函数里添加了一个恶魔圈的绘制
#### 总结
###### 完成弹球-恶魔圈动画
###### 掌握数组对象的splice()方法

